---
title: "CoNVaQ: A short introduction"
author: "Simon J. Larsen"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{CoNVaQ: A short introduction}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r include=FALSE}
library(convaq)
data("example", package="convaq")
results <- readRDS("results.rds")
results2 <- readRDS("results2.rds")
```

This is a short description of what CoNVaQ is and why it is interesting.

## Input data format

CoNVaQ takes as input two sets of segmented CNV calls, one for each group of patients. Each set must be a `data.frame` with the following five columns in **in this order**:

1. `patient`: An identifier for the patient or sample the segment was identified in. All segments with equal patient identifiers will be considered from the same patient/sample.
2. `chr`: Chromosome the position is located in.
3. `start`: First genomic position of the segment in base pairs.
4. `end`: Last genomic position of the segment in base pairs.
5. `type`: The variant type of the segment. Must be one of "Gain", "Loss" or "LOH".

You can load the included synthetic example data set like this:

```r
data("example", package="convaq")
```

The `example` object contains two data frames, `disease` and `healthy`:

```{r}
head(example$disease)
head(example$healthy)
```

## Statistical model

The statistical models searches for CNV regions significantly associated to the patient stratification using Fisher's exact test. To use the statical model, we set the `model`-argument to "statistical". We set the `p.cutoff`-argument to 0.05 to only include regions with $p < 0.05$.

```r
library(convaq)
results <- convaq(
  example$disease, example$healthy,
  model = "statistical",
  name1 = "Disease", name2="Healthy",
  p.cutoff = 0.05
)
```

The `convaq`-function returns a `convaq`-object. We can inspect the object by printing it:

```{r}
print(results)
```

We see that CoNVaQ reports it found 59 statistically significant regions. Use the `regions`-method to obtain these regions.

```r
head(regions(results))
```

```{r echo=FALSE}
knitr::kable(head(regions(results)))
```

If we want to also compute empirical q-values we set the `qvalues`-argument to `TRUE`.
Q-values are computed by repeatedly permutating the patient distributing among the two groups and determining how often we observe a more significant result. To change the number of permutations used, we can set the `qvalues.rep`-argument. A greater value will improve accuracy at the cost of higher computation time.

Let's compute q-values using 2000 repetitions:

```r
results2 <- convaq(
  example$disease, example$healthy,
  model = "statistical",
  name1 = "Disease", name2="Healthy",
  p.cutoff = 0.05,
  qvalues = TRUE,
  qvalues.rep = 2000
)
head(regions(results2))
```

```{r echo=FALSE}
res <- head(regions(results2))
res$pvalue <- as.character(signif(res$pvalue, digits=3))
res$qvalue <- as.character(signif(res$qvalue, digits=3))
knitr::kable(res)
```

If q-values are computed, the output will be sorted on that instead of p-value.

## Query model

This is a quide on how to use the query model.

## Accessing variation frequencies

We can access the frequencies of each type of variation in the reported regions using the `frequencies`-method:
```r
head(frequencies(results))
```

```{r echo=FALSE}
knitr::kable(head(frequencies(results)))
```

Each row corresponds to the same row in the table returned by the `regions`-method. To get a better overview, we can combine the two tables with `cbind`:

```r
cbind(
  head(regions(results)[,c("chr","start","end","pvalue")]),
  head(frequencies(results)[,c(1,4)])
)
```

```{r echo=FALSE}
knitr::kable(cbind(
  head(regions(results)[,c("chr","start","end","pvalue")]),
  head(frequencies(results)[,c(1,4)])
))
```

## Accessing individual sample states

We can access the states of the individual samples in the reported regions using the `states`-method.

```r
head(states(results)[,c(1:3,21:23)])
```

```{r echo=FALSE}
knitr::kable(head(states(results)[,c(1:3,21:23)]))
```

Each row corresponds to the same row in the table returned by the `regions`-method. To get a better overview, we can combine the two tables with `cbind`:

```r
cbind(
  head(regions(results)[,c("chr","start","end","pvalue")]),
  head(states(results)[,c(1:3,21:23)])
)
```

```{r echo=FALSE}
knitr::kable(cbind(
  head(regions(results)[,c("chr","start","end","pvalue")]),
  head(states(results)[,c(1:3,21:23)])
))
```
